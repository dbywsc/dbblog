

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="db">
  <meta name="keywords" content="">
  
    <meta name="description" content="题单来自洛谷 【算法1-6】二分查找与二分答案 P2249 【深基13.例1】查找【深基13.例1】查找题目描述输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a1,a_2,\dots,a{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。 输入格式第一行">
<meta property="og:type" content="article">
<meta property="og:title" content="洛谷二分题单题解">
<meta property="og:url" content="https://dbywsc.github.io/2023/04/09/%E6%B4%9B%E8%B0%B7%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="db的博客">
<meta property="og:description" content="题单来自洛谷 【算法1-6】二分查找与二分答案 P2249 【深基13.例1】查找【深基13.例1】查找题目描述输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a1,a_2,\dots,a{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。 输入格式第一行">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-09T22:18:08.000Z">
<meta property="article:modified_time" content="2023-04-10T13:20:27.755Z">
<meta property="article:author" content="db">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>洛谷二分题单题解 - db的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"dbywsc.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                联系我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="洛谷二分题单题解"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-10 06:18" pubdate>
          2023年4月10日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          112 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">洛谷二分题单题解</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="题单来自洛谷-【算法1-6】二分查找与二分答案"><a href="#题单来自洛谷-【算法1-6】二分查找与二分答案" class="headerlink" title="题单来自洛谷 【算法1-6】二分查找与二分答案"></a>题单来自洛谷 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/training/111#problems">【算法1-6】二分查找与二分答案</a></h2><hr>
<h3 id="P2249-【深基13-例1】查找"><a href="#P2249-【深基13-例1】查找" class="headerlink" title="P2249 【深基13.例1】查找"></a>P2249 【深基13.例1】查找</h3><h1 id="【深基13-例1】查找"><a href="#【深基13-例1】查找" class="headerlink" title="【深基13.例1】查找"></a>【深基13.例1】查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a<em>1,a_2,\dots,a</em>{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行 $2$ 个整数 $n$ 和 $m$，表示数字个数和询问次数。</p>
<p>第二行 $n$ 个整数，表示这些待查询的数字。</p>
<p>第三行 $m$ 个整数，表示询问这些数字的编号，从 $1$ 开始编号。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，$m$ 个整数，以空格隔开，表示答案。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">11 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>数据保证，$1 \leq n \leq 10^6$，$0 \leq a_i,q \leq 10^9$，$1 \leq m \leq 10^5$</p>
<p>本题输入输出量较大，请使用较快的 IO 方式。</p>
<blockquote>
<blockquote>
<p>对于本题，只需要在分别输入数组$a$、$b$后分别查找$b$的每一个元素在$a$中出现的第一个位置即可，需要注意的是当没有找到时输出$-1$，当找到时要输出从$1$开始的编号，所以如果是从$a_0$开始写入数据则输出时要给结果$+1$</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = len;<br><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] == x)<br>            r = mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid] &lt; x)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125; <br>    <span class="hljs-keyword">if</span>(a[r] == x)   <span class="hljs-keyword">return</span> r;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> a[n], b[m];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; b[i];<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">binary_search</span>(a, n, b[i]);<br>        <span class="hljs-keyword">if</span>(t == <span class="hljs-number">-1</span>)<br>            cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; t + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="P1678-烦恼的高考志愿"><a href="#P1678-烦恼的高考志愿" class="headerlink" title="P1678 烦恼的高考志愿"></a>P1678 烦恼的高考志愿</h3><blockquote>
<blockquote>
<h1 id="烦恼的高考志愿"><a href="#烦恼的高考志愿" class="headerlink" title="烦恼的高考志愿"></a>烦恼的高考志愿</h1></blockquote>
</blockquote>
<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有 $m$ 所学校，每所学校预计分数线是 $a_i$。有 $n$ 位学生，估分分别为 $b_i$。</p>
<p>根据 $n$ 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行读入两个整数 $m,n$。$m$ 表示学校数，$n$ 表示学生数。</p>
<p>第二行共有 $m$ 个数，表示 $m$ 个学校的预计录取分数。第三行有 $n$ 个数，表示 $n$ 个学生的估分成绩。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，为最小的不满度之和。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">513 </span><span class="hljs-number">598</span> <span class="hljs-number">567</span> <span class="hljs-number">689</span><br><span class="hljs-symbol">500 </span><span class="hljs-number">600</span> <span class="hljs-number">550</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">32<br></code></pre></td></tr></table></figure>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据范围：</p>
<p>对于 $30\%$ 的数据，$1\leq n,m\leq1000$，估分和录取线 $\leq10000$；</p>
<p>对于 $100\%$ 的数据，$1\leq n,m\leq100000$，估分和录取线 $\leq 1000000$ 且均为正整数。</p>
<blockquote>
<blockquote>
<p>本题可以用二分也可以用其他方法做，我看到题解上用二分的说他ac了，但是我复制了他的代码发现最后一个附加数据无法通过，我自己的代码也是最后一个数据超时，应该是想要ac就得用其他方法做</p>
<p>本题的思路是找到录取分数中与估分成绩分差最小的分数，求得每一个估分成绩的分差（也就是二者相减的绝对值）然后加起来就能得到所求的最小不满度之和。需要注意的是本题并没有说明输入的数据是有序的，所以在输入$m$个预计录取分数后要先对其排序才能使用二分</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">//直接用里面的sort函数</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search_binary</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len - <span class="hljs-number">1</span>;  <span class="hljs-comment">//左边界是a[]中的最低分(下标），又边界是最高分（下标）</span><br><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &lt;= x)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(a[l] - b[i]), <span class="hljs-built_in">abs</span>(a[r] - b[i]));<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-type">int</span> a[m], b[n];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">sort</span>(a, a + m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; b[i];<br>        ans += <span class="hljs-built_in">search_binary</span>(a, b, m, b[i], i);<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="P1873-COCI-2011-2012-5-EKO-砍树"><a href="#P1873-COCI-2011-2012-5-EKO-砍树" class="headerlink" title="P1873 [COCI 2011/2012 #5] EKO / 砍树"></a>P1873 [COCI 2011/2012 #5] EKO / 砍树</h3><h1 id="COCI-2011-2012-5-EKO-砍树"><a href="#COCI-2011-2012-5-EKO-砍树" class="headerlink" title="[COCI 2011/2012 #5] EKO / 砍树"></a>[COCI 2011/2012 #5] EKO / 砍树</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>伐木工人 Mirko 需要砍 $M$ 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。</p>
<p>Mirko 的伐木机工作流程如下：Mirko 设置一个高度参数 $H$（米），伐木机升起一个巨大的锯片到高度 $H$，并锯掉所有树比 $H$ 高的部分（当然，树木不高于 $H$ 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 $20,15,10$ 和 $17$，Mirko 把锯片升到 $15$ 米的高度，切割后树木剩下的高度将是 $15,15,10$ 和 $15$，而 Mirko 将从第 $1$ 棵树得到 $5$ 米，从第 $4$ 棵树得到 $2$ 米，共得到 $7$ 米木材。</p>
<p>Mirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 $H$，使得他能得到的木材至少为 $M$ 米。换句话说，如果再升高 $1$ 米，他将得不到 $M$ 米木材。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行 $2$ 个整数 $N$ 和 $M$，$N$ 表示树木的数量，$M$ 表示需要的木材总长度。</p>
<p>第 $2$ 行 $N$ 个整数表示每棵树的高度。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>$1$ 个整数，表示锯片的最高高度。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">15</span> <span class="hljs-number">10</span> <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">15<br></code></pre></td></tr></table></figure>
<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">20</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">42</span> <span class="hljs-number">40</span> <span class="hljs-number">26</span> <span class="hljs-number">46</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">36<br></code></pre></td></tr></table></figure>
<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>对于 $100\%$ 的测试数据，$1\le N\le10^6$，$1\le M\le2\times10^9$，树的高度 $<10^9$，所有树的高度总和 $>M$。</p>
<blockquote>
<blockquote>
<p>这道题的思路是从低到高枚举锯片的高度，如果锯片在某个高度砍树后的长度能够达到需要的总长度（大于等于），我们就将左边界移到当前高度，如果无法达到（小于），就将右边界移到当前高度</p>
<p>需要注意的地方是如果树的高度没有锯片高，则砍不下来任何的木材，所以我们应该将锯片的左边界设置为0，右边界设置为给出的树木中最高的树的高度</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> max)</span> </span>&#123;<br>    <span class="hljs-type">long</span> l = <span class="hljs-number">0</span>, r = max;<br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">long</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span>(a[i] &gt; mid)<br>                t += a[i] - mid;    <span class="hljs-comment">//如果树比锯片高，就将砍下的木材的长度累加</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(t &gt;= x)  <span class="hljs-comment">//如果木材的长度达到了要求的长度设置左边界</span><br>            l = mid;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">//反之设置右边界</span><br>            r = mid;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l;   <span class="hljs-comment">//此时得到的左边界就是答案</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">long</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">long</span> a[n];<br><br>    <span class="hljs-type">long</span> maxn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        maxn = <span class="hljs-built_in">max</span>(maxn, a[i]); <span class="hljs-comment">//求得最高的树，作为右边界</span><br>    &#125;<br><br>    <span class="hljs-type">long</span> ans = <span class="hljs-built_in">binary_search</span>(a, n, m, maxn);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<hr>
<h3 id="P2440-木材加工"><a href="#P2440-木材加工" class="headerlink" title="P2440 木材加工"></a>P2440 木材加工</h3><h1 id="木材加工"><a href="#木材加工" class="headerlink" title="木材加工"></a>木材加工</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>要保护环境</p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>木材厂有 $n$ 根原木，现在想把这些木头切割成 $k$ 段长度<strong>均</strong>为 $l$ 的小段木头（木头有可能有剩余）。</p>
<p>当然，我们希望得到的小段木头越长越好，请求出 $l$ 的最大值。</p>
<p>木头长度的单位是 $\text{cm}$，原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。</p>
<p>例如有两根原木长度分别为 $11$ 和 $21$，要求切割成等长的 $6$ 段，很明显能切割出来的小段木头长度最长为 $5$。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是两个正整数 $n,k$，分别表示原木的数量，需要得到的小段的数量。</p>
<p>接下来 $n$ 行，每行一个正整数 $L_i$，表示一根原木的长度。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行，即 $l$ 的最大值。</p>
<p>如果连 $\text{1cm}$ 长的小段都切不出来，输出 <code>0</code>。</p>
<h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">7</span><br><span class="hljs-number">232</span><br><span class="hljs-number">124</span><br><span class="hljs-number">456</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">114<br></code></pre></td></tr></table></figure>
<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100\%$ 的数据，有 $1\le n\le 10^5$，$1\le k\le 10^8$，$1\le L_i\le 10^8(i\in[1,n])$。</p>
<blockquote>
<blockquote>
<p>这道题和上一题有点像，我们还是通过二分枚举每一段的长度，如果在当前长度下可以切割出$k$段木头就将边界左移，反之右移。左边界为$0$，右边界为最高的木头的长度。同时本题并没有说明$L$是有序的，所以我们要先排序再二分</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> max, <span class="hljs-type">long</span> x)</span> </span>&#123;<br>    <span class="hljs-type">long</span> l = <span class="hljs-number">0</span>, r = max;<br><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">long</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            t += a[i] / mid;    <span class="hljs-comment">//当前长度下能够切割成多少段</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(t &gt;= x)<br>            l = mid;    <span class="hljs-comment">//当前长度足够切割出k段木头，边界左移</span><br>        <span class="hljs-keyword">else</span><br>            r = mid;    <span class="hljs-comment">//当前长度不够切割k段，边界右移</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l;   <span class="hljs-comment">//l就是答案</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">long</span> n, k, maxn = <span class="hljs-number">0</span>;;<br>    cin &gt;&gt; n &gt;&gt; k;<br><br>    <span class="hljs-type">long</span> l[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; l[i];<br>        maxn = <span class="hljs-built_in">max</span>(maxn, l[i]);<br>    &#125;<br>        <br>    <span class="hljs-built_in">sort</span>(l, l + n);<br><br>    <span class="hljs-type">long</span> ans = <span class="hljs-built_in">binary_search</span>(l, n, maxn, k);<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="P2678-NOIP2015-提高组-跳石头"><a href="#P2678-NOIP2015-提高组-跳石头" class="headerlink" title="P2678 [NOIP2015 提高组] 跳石头"></a>P2678 [NOIP2015 提高组] 跳石头</h3><h1 id="NOIP2015-提高组-跳石头"><a href="#NOIP2015-提高组-跳石头" class="headerlink" title="[NOIP2015 提高组] 跳石头"></a>[NOIP2015 提高组] 跳石头</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>一年一度的“跳石头”比赛又要开始了!</p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p>
<p>为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。</p>
<h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \geq 1$ 且 $N \geq M \geq 0$。</p>
<p>接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i( 0 &lt; D_i &lt; L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。</p>
<h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即最短跳跃距离的最大值。</p>
<h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">25 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <br><span class="hljs-number">2</span><br><span class="hljs-number">11</span><br><span class="hljs-number">14</span><br><span class="hljs-symbol">17 </span><br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure>
<h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><h3 id="输入输出样例-1-说明"><a href="#输入输出样例-1-说明" class="headerlink" title="输入输出样例 1 说明"></a>输入输出样例 1 说明</h3><p>将与起点距离为 $2$和 $14$ 的两个岩石移走后,最短的跳跃距离为 $4$(从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石,或者从距离 $21$ 的岩石跳到终点)。</p>
<h3 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于 $20\%$的数据，$0 \le M \le N \le 10$。<br>对于 $50\%$ 的数据，$0 \le M \le N \le 100$。<br>对于 $100\%$的数据，$0 \le M \le N \le 50000,1 \le L<br> \le 10^9$。</p>
<blockquote>
<blockquote>
<p>我们发现无论如何，跳跃距离的最大值都不会超过起点到终点的距离，所以本题的思路是从起点到终点之间二分，然后进行判断。如果起点和中间之间任意两个石头间的距离小于当前的距离，则需要移去一个石头，否则进行下一次判断。所有判断结束后如果要移走的石头数超过了可移走数$M$，则当前的距离不是最短跳跃距离的最大值，边界左移，否则边界右移</p>
<p>需要注意的地方是起点到终点之间有$N$块石头，如果算上起点和终点的话实际上有$N + 2$块石头，另外二分的判断过程有些复杂，所以我们按照标准的二分写法写一个判断函数<code>judge()</code>来进行判断</p>
</blockquote>
</blockquote>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> mid, <span class="hljs-type">long</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len + <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">//在第一块石头和终点间进行判断</span><br>        <span class="hljs-keyword">if</span>(a[i] - a[now] &lt; mid)<br>            cnt++;<br>        <span class="hljs-keyword">else</span><br>            now = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt &lt;= m;    <span class="hljs-comment">/* </span><br><span class="hljs-comment">                            等价于:</span><br><span class="hljs-comment">                            if(cnt &lt;= m)</span><br><span class="hljs-comment">                                return true;</span><br><span class="hljs-comment">                            return false;</span><br><span class="hljs-comment">                        */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> distance, <span class="hljs-type">long</span> m)</span> </span>&#123;<br>    <span class="hljs-type">long</span> l = <span class="hljs-number">0</span>, r = distance + <span class="hljs-number">1</span>;    <span class="hljs-comment">//边界是起点和终点，避免特判将终点+1</span><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">long</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(a, len, mid, m))<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> l;   <span class="hljs-comment">//此时左边界就是所求的最短跳跃距离的最大值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">long</span> l, n, m, ans;<br>    cin &gt;&gt; l &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-type">long</span> a[n + <span class="hljs-number">2</span>];  <span class="hljs-comment">//实际上有n + 2个石头，我们把a[0]作为起点，a[n + 1]作为终点</span><br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    a[n + <span class="hljs-number">1</span>] = l;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br>    <br>    ans = <span class="hljs-built_in">binary_search</span>(a, n, l, m);<br>    <br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="P1182-数列分段-Section-II"><a href="#P1182-数列分段-Section-II" class="headerlink" title="P1182 数列分段 Section II"></a>P1182 数列分段 Section II</h3><h1 id="数列分段-Section-II"><a href="#数列分段-Section-II" class="headerlink" title="数列分段 Section II"></a>数列分段 Section II</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>对于给定的一个长度为N的正整数数列 $A_{1\sim N}$，现要将其分成 $M$（$M\leq N$）段，并要求每段连续，且每段和的最大值最小。</p>
<p>关于最大值最小：</p>
<p>例如一数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段。</p>
<p>将其如下分段：</p>
<script type="math/tex; mode=display">[4\ 2][4\ 5][1]</script><p>第一段和为 $6$，第 $2$ 段和为 $9$，第 $3$ 段和为 $1$，和最大值为 $9$。</p>
<p>将其如下分段：</p>
<script type="math/tex; mode=display">[4][2\ 4][5\ 1]</script><p>第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$，和最大值为 $6$。</p>
<p>并且无论如何分段，最大值不会小于 $6$。</p>
<p>所以可以得到要将数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$。</p>
<h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行包含两个正整数 $N,M$。  </p>
<p>第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，含义如题目所述。</p>
<h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个正整数，即每段和最大值最小为多少。</p>
<h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure>
<h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>对于 $20\%$ 的数据，$N\leq 10$。</p>
<p>对于 $40\%$ 的数据，$N\leq 1000$。</p>
<p>对于 $100\%$ 的数据，$1\leq N\leq 10^5$，$M\leq N$，$A_i &lt; 10^8$， 答案不超过 $10^9$。</p>
<blockquote>
<blockquote>
<p><del>这道题看了大半天题解才知道怎么做</del><br>我们的思路是直接二分每段和的最大值，当按照这个最大值划分的段数超过指定的段数时就证明当前的值并非最大值，要继续往右搜索，相反如果段数没有达到指定段数就说明当前值超过了最大值，要往左搜索<br>所以对于本题的左边界应该为将$n$个数分成$n$段时的每段和的最大值，即数列$A_n$的最大值，右边界为将$A_n$划分为一段时这段的长度，即$sumA_n$</p>
<p>另外本题所用的二分模板和上面几道题的二分模板不同，两个模板的思路是相同的，但是对于本题我们在求得$mid$后还需要根据是否满足$judge()$向终点的左边或右边搜索<del>其实这个模板做上面的题也可以，只是我不喜欢这样写</del></p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> m)</span> </span>&#123;<br>    <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里我是这样理解的：任何情况下都至少会将数列分成1层</span><br><span class="hljs-comment">        所以我们直接从一层开始计算。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span>(sum + a[i] &lt;= x) &#123; <span class="hljs-comment">//当累加的值还没有超过最大值时，不算做一层，继续累加</span><br>            sum += a[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cnt ++;     <span class="hljs-comment">//当累加值超过最大值时，已经达到了一层，层数+1</span><br>            sum = a[i]; <span class="hljs-comment">//从当前元素开始累加进行新一层的计算</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cnt &lt;= m;    <span class="hljs-comment">//当cnt不超过m时说明当前的值达到了最大值，移动右边界</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> maxn, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">long</span> sum, <span class="hljs-type">long</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> l = maxn, r = sum;<br>    <span class="hljs-keyword">while</span>(l &lt;= r) &#123;<br>        <span class="hljs-type">long</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(a, len, mid, m)) &#123;<br>            r = mid - <span class="hljs-number">1</span>;    <span class="hljs-comment">//向左搜索</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            l = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">//向右搜索</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l;   <span class="hljs-comment">//此时左端点就是最大值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">long</span> n, m, maxn = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">long</span> a[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        maxn = <span class="hljs-built_in">max</span>(maxn, a[i]); <span class="hljs-comment">//左端点</span><br>        cnt += a[i];    <span class="hljs-comment">//右端点</span><br>    &#125;<br>    <br>    <span class="hljs-type">long</span> ans = <span class="hljs-built_in">binary_search</span>(a, n, maxn, cnt, m);<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="P3743-kotori的设备"><a href="#P3743-kotori的设备" class="headerlink" title="P3743 kotori的设备"></a>P3743 kotori的设备</h3><h1 id="kotori的设备"><a href="#kotori的设备" class="headerlink" title="kotori的设备"></a>kotori的设备</h1><h2 id="题目背景-3"><a href="#题目背景-3" class="headerlink" title="题目背景"></a>题目背景</h2><p>kotori 有 $n$ 个可同时使用的设备。</p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>第 $i$ 个设备每秒消耗 $a_i$ 个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在 $k$ 秒内消耗的能量均为 $k\times a_i$ 单位。在开始的时候第 $i$ 个设备里存储着 $b_i$ 个单位能量。</p>
<p>同时 kotori 又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 $p$ 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。</p>
<p>kotori 想把这些设备一起使用，直到其中有设备能量降为  $0$。所以 kotori 想知道，在充电器的作用下，她最多能将这些设备一起使用多久。</p>
<h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行给出两个整数 $n,p$。</p>
<p>接下来 $n$ 行，每行表示一个设备，给出两个整数，分别是这个设备的 $a_i$ 和 $b_i$。</p>
<h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果 kotori 可以无限使用这些设备，输出 $-1$。</p>
<p>否则输出 kotori 在其中一个设备能量降为 $0$ 之前最多能使用多久。</p>
<p>设你的答案为 $a$，标准答案为 $b$，只有当 $a,b$ 满足<br>$\dfrac{|a-b|}{\max(1,b)} \leq 10^{-4}$ 的时候，你能得到本测试点的满分。</p>
<h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">0000000000</span><br></code></pre></td></tr></table></figure>
<h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">100</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure>
<h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">5000000000</span><br></code></pre></td></tr></table></figure>
<h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq p\leq 100000$，$1\leq a_i,b_i\leq100000$。</p>
<blockquote>
<blockquote>
<p>对于本题，我们可以理解为当k秒内消耗的电量$k\times a<em>i$超过了其本身的电量$b_i$，那么它在若干秒后就会用完电量，而我们要在使用所有设备的同时尽量让它们的使用时间长，也就是说要让第一个设备电量用完的情况尽可能晚的出现。我们可以让目前电量最少的设备接上充电宝，此时它的耗电就成了$k\times (a_i - p)$，当其它设备成为电量最少的设备时，我们将充电宝重新接到这个设备上<br>由于切换设备的时间是忽略不计的，我们可以当作以上行为是可以在瞬间内完成的，所以我们可以直接将它们累加到一起直接进行计算。那么我们就有了$n$个设备每秒消耗的电量$\sum</em>{i=1}^{n} a_i$    </p>
<p>现在我们需要考虑如何通过程序来解决问题<br>我们可以二分查找这些设备的最大使用时间$x$，那么在x秒内我们通过充电宝一共可以供电$x \times p$，我们记作$q$。现在对每一个设备进行判断，如果第$i$个设备$x$秒内消耗的电量$a<em>i \times x$没有超过这个设备本身的电量$b_i$，就说明这个设备不需要充电，如果超过了这个电量我们就需要冲$a_i \times x - b_i$的电，最后所有设备一共要冲$\sum</em>{i=1}^{n} a<em>i \times x - b_i$的电，我们记作$sum$，如果$sum &gt; q$说明当前的时间超过了最大使用时间，应该将右边界左移缩小范围；反之如果$sum \leq q$，说明当前时间没有超过最大使用时间，应该移动左边界继续查找。<br>另外当可以无限使用设备，即永远不会有设备没电时输出$-1$。我们可以进行特判，当可以无限使用设备时就说明所有设备每秒消耗的总电量永远不会超过充电宝每秒充入的电量，是否还记得上面的$\sum</em>{i=1}^{n} a_i$，我们将其记作$t$，那么当$t \leq p$时，输出$-1$</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> a[], <span class="hljs-type">double</span> b[], <span class="hljs-type">double</span> p,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">long</span> len)</span> </span>&#123;<br>        <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>, q = x * p;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span>(a[i] * x &lt;= b[i])<br>                <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">//不需要充电，判断下一个</span><br>            <span class="hljs-keyword">else</span><br>                sum += (a[i] * x - b[i]);   <span class="hljs-comment">//对需要充入的电量累加</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sum &lt;= q;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            如果充入的电量没有超过x秒内可以提供的电量</span><br><span class="hljs-comment">            则当前结果可行</span><br><span class="hljs-comment">        */</span><br>    &#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">double</span> a[], <span class="hljs-type">double</span> b[], <span class="hljs-type">long</span> len,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span> p)</span> </span>&#123;<br>        <span class="hljs-type">double</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e10</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            直接将左端点定义为0，右端点定义为足够大的值</span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">             二分的时间复杂度是O(logn)，当执行一千次时精度绝对可以满足题目要求，可以省去对边界的判断</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;     <br>            <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid, a, b, p, len))<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> l;   <span class="hljs-comment">//此时左端点就为答案</span><br>    &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">long</span> n;<br>    <span class="hljs-type">double</span> p, t = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; p;<br>    <span class="hljs-type">double</span> a[n], b[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i] &gt;&gt; b[i];<br>        t += a[i];  <span class="hljs-comment">//对每秒消耗的电量进行累加</span><br>    &#125;<br><br>    ans = <span class="hljs-built_in">binary_search</span>(a, b, n, p);<br>    <span class="hljs-keyword">if</span>(t &lt;= p)   <span class="hljs-comment">//特判</span><br>        ans = <span class="hljs-number">-1</span>;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<hr>
<h3 id="P3853-TJOI2007-路标设置"><a href="#P3853-TJOI2007-路标设置" class="headerlink" title="P3853 [TJOI2007]路标设置"></a>P3853 [TJOI2007]路标设置</h3><h1 id="TJOI2007-路标设置"><a href="#TJOI2007-路标设置" class="headerlink" title="[TJOI2007]路标设置"></a>[TJOI2007]路标设置</h1><h2 id="题目背景-4"><a href="#题目背景-4" class="headerlink" title="题目背景"></a>题目背景</h2><p>B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。</p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。</p>
<h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行包括三个数 $L,N,K$，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。</p>
<p>第 $2$ 行包括递增排列的 $N$ 个整数，分别表示原有的 $N$ 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 $[0,L]$ 内。</p>
<h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $1$ 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。</p>
<h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">101 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">101</span><br></code></pre></td></tr></table></figure>
<h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">51<br></code></pre></td></tr></table></figure>
<h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。</p>
<p>$50\%$ 的数据中，$2 \leq N \leq 100$，$0 \leq K \leq 100$。</p>
<p>$100\%$ 的数据中，$2 \leq N \leq 100000$, $0 \leq K \leq100000$。</p>
<p>$100\%$ 的数据中，$0 &lt; L \leq 10000000$。</p>
<blockquote>
<blockquote>
<p>这道题是这个题单中唯一一道普及+/提高的题，不过要理解起来其实也很容易。实际上这道题和上面的<code>[NOIP2015 提高组] 跳石头</code>有点像，只是跳石头是在最短跳跃距离的最大值，本题是在求最小的“空旷指数”值</p>
<p>本题也是用通过二分查找能够满足要求的“空旷指数”<del>（也就是二分答案，但是之前好像没有提到过）</del>，根据题目我们知道路标的位值一定在区间$[0, L]$内，所以我们可以将左右边界分别定义为$0$和输入的$L$<br>那么本题的思路就是判断每两个相邻路标之间的距离，如果距离大于我们给定的“空旷指数”$mid$，我们就在与第一个路标距离$mid$处添加一个路标，然后再次进行判断，知道两个路标之间距离小于$mid$，依次枚举后，我们就得到了在当前“空旷指数”下要添加的路标数$cnt$，当添加的路标数量超过了规定的最多可增设路标数量$k$，也就是$cnt &gt; k$时，说明目前的答案大于最小空旷指数，我们应该移动左端点，相反当$cnt \geq k$时，我们移动右端点，判断结束后右端点就是我们的答案<br>本题最值的注意的地方时我们进行二分时如果$cnt &gt; k$时，移动的是<strong>左端点</strong>，而最终答案是<strong>右端点</strong>，这与我们之前的题目相反。另外本题我们需要输入$n$个数，但是包含这些数的数组长度应该是$n + 2$，因为我我们需要用第一个元素存储起点，最后一个元素存储终点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len + <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> dinstance = a[i] - a[i - <span class="hljs-number">1</span>];     <span class="hljs-comment">//用来存放两个路标间的距离也就是“空旷指数”</span><br>        <span class="hljs-keyword">if</span>(dinstance &gt; mid) &#123; <span class="hljs-comment">//如果两个路标间的距离大于mid，增设路标</span><br>            cnt++;<br>            <span class="hljs-type">int</span> t = dinstance - mid;<br>            <span class="hljs-keyword">while</span>(t &gt; mid) &#123;    <span class="hljs-comment">//增设路标后继续判断，直到路标间的距离不超过mid</span><br>                cnt++;<br>                t -= mid;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cnt &lt;= k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> finish, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = finish;   <span class="hljs-comment">//参数finish即终点（准确的说是终点到起点的距离）</span><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;     <span class="hljs-comment">//本题还是用这个二分模板，我个人很喜欢这个模板，能省去不少判断边界的麻烦</span><br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid, a, len, k))<br>            r = mid;            <span class="hljs-comment">//注意此时要移动右端点</span><br>        <span class="hljs-keyword">else</span><br>            l = mid;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> r;       <span class="hljs-comment">//答案也是右端点</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l, n, k;<br>    cin &gt;&gt; l &gt;&gt; n &gt;&gt; k;<br><br>    <span class="hljs-type">int</span> a[n + <span class="hljs-number">2</span>];<br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;       <span class="hljs-comment">//存放起点</span><br>    a[n + <span class="hljs-number">1</span>] = l;   <span class="hljs-comment">//存放终点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">binary_search</span>(a, n, l, k);<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<p>实际上这个题单还有两道题，但是一道据说用二分只是一种特殊解法，实际上应该是双指针的模板题<del>而且我还不会做</del>，另一道题看不明白，所以这里就不写了<del>看以后有没有心情去做</del>，所以这个二分题单在这里就告一段落</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>洛谷二分题单题解</div>
      <div>https://dbywsc.github.io/2023/04/09/洛谷二分题单题解/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>db</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/03/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="二分查找">
                        <span class="hidden-mobile">二分查找</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://dbywsc.github.io/2023/04/09/%E6%B4%9B%E8%B0%B7%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95%E9%A2%98%E8%A7%A3/';
          this.page.identifier = '/2023/04/09/%E6%B4%9B%E8%B0%B7%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95%E9%A2%98%E8%A7%A3/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>洛谷二分题单题解</title>
    <link href="/2023/04/09/%E6%B4%9B%E8%B0%B7%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/04/09/%E6%B4%9B%E8%B0%B7%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="题单来自洛谷-【算法1-6】二分查找与二分答案"><a href="#题单来自洛谷-【算法1-6】二分查找与二分答案" class="headerlink" title="题单来自洛谷 【算法1-6】二分查找与二分答案"></a>题单来自洛谷 <a href="https://www.luogu.com.cn/training/111#problems">【算法1-6】二分查找与二分答案</a></h2><hr><h3 id="P2249-【深基13-例1】查找"><a href="#P2249-【深基13-例1】查找" class="headerlink" title="P2249 【深基13.例1】查找"></a>P2249 【深基13.例1】查找</h3><h1 id="【深基13-例1】查找"><a href="#【深基13-例1】查找" class="headerlink" title="【深基13.例1】查找"></a>【深基13.例1】查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a_1,a_2,\dots,a_{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行 $2$ 个整数 $n$ 和 $m$，表示数字个数和询问次数。</p><p>第二行 $n$ 个整数，表示这些待查询的数字。</p><p>第三行 $m$ 个整数，表示询问这些数字的编号，从 $1$ 开始编号。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，$m$ 个整数，以空格隔开，表示答案。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">11 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>数据保证，$1 \leq n \leq 10^6$，$0 \leq a_i,q \leq 10^9$，$1 \leq m \leq 10^5$</p><p>本题输入输出量较大，请使用较快的 IO 方式。</p><blockquote><blockquote><p>对于本题，只需要在分别输入数组$a$、$b$后分别查找$b$的每一个元素在$a$中出现的第一个位置即可，需要注意的是当没有找到时输出$-1$，当找到时要输出从$1$开始的编号，所以如果是从$a_0$开始写入数据则输出时要给结果$+1$</p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = len;<br><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] == x)<br>            r = mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid] &lt; x)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125; <br>    <span class="hljs-keyword">if</span>(a[r] == x)   <span class="hljs-keyword">return</span> r;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> a[n], b[m];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; b[i];<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">binary_search</span>(a, n, b[i]);<br>        <span class="hljs-keyword">if</span>(t == <span class="hljs-number">-1</span>)<br>            cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; t + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="P1678-烦恼的高考志愿"><a href="#P1678-烦恼的高考志愿" class="headerlink" title="P1678 烦恼的高考志愿"></a>P1678 烦恼的高考志愿</h3><blockquote><blockquote><h1 id="烦恼的高考志愿"><a href="#烦恼的高考志愿" class="headerlink" title="烦恼的高考志愿"></a>烦恼的高考志愿</h1></blockquote></blockquote><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有 $m$ 所学校，每所学校预计分数线是 $a_i$。有 $n$ 位学生，估分分别为 $b_i$。</p><p>根据 $n$ 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行读入两个整数 $m,n$。$m$ 表示学校数，$n$ 表示学生数。</p><p>第二行共有 $m$ 个数，表示 $m$ 个学校的预计录取分数。第三行有 $n$ 个数，表示 $n$ 个学生的估分成绩。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，为最小的不满度之和。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">513 </span><span class="hljs-number">598</span> <span class="hljs-number">567</span> <span class="hljs-number">689</span><br><span class="hljs-symbol">500 </span><span class="hljs-number">600</span> <span class="hljs-number">550</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">32<br></code></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据范围：</p><p>对于 $30%$ 的数据，$1\leq n,m\leq1000$，估分和录取线 $\leq10000$；</p><p>对于 $100%$ 的数据，$1\leq n,m\leq100000$，估分和录取线 $\leq 1000000$ 且均为正整数。</p><blockquote><blockquote><p>本题可以用二分也可以用其他方法做，我看到题解上用二分的说他ac了，但是我复制了他的代码发现最后一个附加数据无法通过，我自己的代码也是最后一个数据超时，应该是想要ac就得用其他方法做</p></blockquote></blockquote><blockquote><blockquote><p>本题的思路是找到录取分数中与估分成绩分差最小的分数，求得每一个估分成绩的分差（也就是二者相减的绝对值）然后加起来就能得到所求的最小不满度之和。需要注意的是本题并没有说明输入的数据是有序的，所以在输入$m$个预计录取分数后要先对其排序才能使用二分</p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">//直接用里面的sort函数</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search_binary</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len - <span class="hljs-number">1</span>;  <span class="hljs-comment">//左边界是a[]中的最低分(下标），又边界是最高分（下标）</span><br><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &lt;= x)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(a[l] - b[i]), <span class="hljs-built_in">abs</span>(a[r] - b[i]));<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-type">int</span> a[m], b[n];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">sort</span>(a, a + m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; b[i];<br>        ans += <span class="hljs-built_in">search_binary</span>(a, b, m, b[i], i);<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="P1873-COCI-2011-x2F-2012-5-EKO-x2F-砍树"><a href="#P1873-COCI-2011-x2F-2012-5-EKO-x2F-砍树" class="headerlink" title="P1873 [COCI 2011&#x2F;2012 #5] EKO &#x2F; 砍树"></a>P1873 [COCI 2011&#x2F;2012 #5] EKO &#x2F; 砍树</h3><h1 id="COCI-2011-x2F-2012-5-EKO-x2F-砍树"><a href="#COCI-2011-x2F-2012-5-EKO-x2F-砍树" class="headerlink" title="[COCI 2011&#x2F;2012 #5] EKO &#x2F; 砍树"></a>[COCI 2011&#x2F;2012 #5] EKO &#x2F; 砍树</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>伐木工人 Mirko 需要砍 $M$ 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。</p><p>Mirko 的伐木机工作流程如下：Mirko 设置一个高度参数 $H$（米），伐木机升起一个巨大的锯片到高度 $H$，并锯掉所有树比 $H$ 高的部分（当然，树木不高于 $H$ 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 $20,15,10$ 和 $17$，Mirko 把锯片升到 $15$ 米的高度，切割后树木剩下的高度将是 $15,15,10$ 和 $15$，而 Mirko 将从第 $1$ 棵树得到 $5$ 米，从第 $4$ 棵树得到 $2$ 米，共得到 $7$ 米木材。</p><p>Mirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 $H$，使得他能得到的木材至少为 $M$ 米。换句话说，如果再升高 $1$ 米，他将得不到 $M$ 米木材。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行 $2$ 个整数 $N$ 和 $M$，$N$ 表示树木的数量，$M$ 表示需要的木材总长度。</p><p>第 $2$ 行 $N$ 个整数表示每棵树的高度。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>$1$ 个整数，表示锯片的最高高度。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">15</span> <span class="hljs-number">10</span> <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">15<br></code></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">20</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">42</span> <span class="hljs-number">40</span> <span class="hljs-number">26</span> <span class="hljs-number">46</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">36<br></code></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>对于 $100%$ 的测试数据，$1\le N\le10^6$，$1\le M\le2\times10^9$，树的高度 $&lt;10^9$，所有树的高度总和 $&gt;M$。</p><blockquote><blockquote><p>这道题的思路是从低到高枚举锯片的高度，如果锯片在某个高度砍树后的长度能够达到需要的总长度（大于等于），我们就将左边界移到当前高度，如果无法达到（小于），就将右边界移到当前高度</p></blockquote></blockquote><blockquote><blockquote><p>需要注意的地方是如果树的高度没有锯片高，则砍不下来任何的木材，所以我们应该将锯片的左边界设置为0，右边界设置为给出的树木中最高的树的高度</p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> max)</span> </span>&#123;<br>    <span class="hljs-type">long</span> l = <span class="hljs-number">0</span>, r = max;<br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">long</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span>(a[i] &gt; mid)<br>                t += a[i] - mid;    <span class="hljs-comment">//如果树比锯片高，就将砍下的木材的长度累加</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(t &gt;= x)  <span class="hljs-comment">//如果木材的长度达到了要求的长度设置左边界</span><br>            l = mid;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">//反之设置右边界</span><br>            r = mid;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l;   <span class="hljs-comment">//此时得到的左边界就是答案</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">long</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">long</span> a[n];<br><br>    <span class="hljs-type">long</span> maxn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        maxn = <span class="hljs-built_in">max</span>(maxn, a[i]); <span class="hljs-comment">//求得最高的树，作为右边界</span><br>    &#125;<br><br>    <span class="hljs-type">long</span> ans = <span class="hljs-built_in">binary_search</span>(a, n, m, maxn);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr><h3 id="P2440-木材加工"><a href="#P2440-木材加工" class="headerlink" title="P2440 木材加工"></a>P2440 木材加工</h3><h1 id="木材加工"><a href="#木材加工" class="headerlink" title="木材加工"></a>木材加工</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>要保护环境</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>木材厂有 $n$ 根原木，现在想把这些木头切割成 $k$ 段长度<strong>均</strong>为 $l$ 的小段木头（木头有可能有剩余）。</p><p>当然，我们希望得到的小段木头越长越好，请求出 $l$ 的最大值。</p><p>木头长度的单位是 $\text{cm}$，原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。</p><p>例如有两根原木长度分别为 $11$ 和 $21$，要求切割成等长的 $6$ 段，很明显能切割出来的小段木头长度最长为 $5$。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是两个正整数 $n,k$，分别表示原木的数量，需要得到的小段的数量。</p><p>接下来 $n$ 行，每行一个正整数 $L_i$，表示一根原木的长度。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行，即 $l$ 的最大值。</p><p>如果连 $\text{1cm}$ 长的小段都切不出来，输出 <code>0</code>。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">7</span><br><span class="hljs-number">232</span><br><span class="hljs-number">124</span><br><span class="hljs-number">456</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">114<br></code></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100%$ 的数据，有 $1\le n\le 10^5$，$1\le k\le 10^8$，$1\le L_i\le 10^8(i\in[1,n])$。</p><blockquote><blockquote><p>这道题和上一题有点像，我们还是通过二分枚举每一段的长度，如果在当前长度下可以切割出$k$段木头就将边界左移，反之右移。左边界为$0$，右边界为最高的木头的长度。同时本题并没有说明$L$是有序的，所以我们要先排序再二分</p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> max, <span class="hljs-type">long</span> x)</span> </span>&#123;<br>    <span class="hljs-type">long</span> l = <span class="hljs-number">0</span>, r = max;<br><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">long</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            t += a[i] / mid;    <span class="hljs-comment">//当前长度下能够切割成多少段</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(t &gt;= x)<br>            l = mid;    <span class="hljs-comment">//当前长度足够切割出k段木头，边界左移</span><br>        <span class="hljs-keyword">else</span><br>            r = mid;    <span class="hljs-comment">//当前长度不够切割k段，边界右移</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l;   <span class="hljs-comment">//l就是答案</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">long</span> n, k, maxn = <span class="hljs-number">0</span>;;<br>    cin &gt;&gt; n &gt;&gt; k;<br><br>    <span class="hljs-type">long</span> l[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; l[i];<br>        maxn = <span class="hljs-built_in">max</span>(maxn, l[i]);<br>    &#125;<br>        <br>    <span class="hljs-built_in">sort</span>(l, l + n);<br><br>    <span class="hljs-type">long</span> ans = <span class="hljs-built_in">binary_search</span>(l, n, maxn, k);<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="P2678-NOIP2015-提高组-跳石头"><a href="#P2678-NOIP2015-提高组-跳石头" class="headerlink" title="P2678 [NOIP2015 提高组] 跳石头"></a>P2678 [NOIP2015 提高组] 跳石头</h3><h1 id="NOIP2015-提高组-跳石头"><a href="#NOIP2015-提高组-跳石头" class="headerlink" title="[NOIP2015 提高组] 跳石头"></a>[NOIP2015 提高组] 跳石头</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>一年一度的“跳石头”比赛又要开始了!</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p><p>为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \geq 1$ 且 $N \geq M \geq 0$。</p><p>接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i( 0 &lt; D_i &lt; L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即最短跳跃距离的最大值。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">25 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <br><span class="hljs-number">2</span><br><span class="hljs-number">11</span><br><span class="hljs-number">14</span><br><span class="hljs-symbol">17 </span><br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><h3 id="输入输出样例-1-说明"><a href="#输入输出样例-1-说明" class="headerlink" title="输入输出样例 1 说明"></a>输入输出样例 1 说明</h3><p>将与起点距离为 $2$和 $14$ 的两个岩石移走后,最短的跳跃距离为 $4$(从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石,或者从距离 $21$ 的岩石跳到终点)。</p><h3 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于 $20%$的数据，$0 \le M \le N \le 10$。<br>对于 $50%$ 的数据，$0 \le M \le N \le 100$。<br>对于 $100%$的数据，$0 \le M \le N \le 50000,1 \le L<br> \le 10^9$。</p><blockquote><blockquote><p>我们发现无论如何，跳跃距离的最大值都不会超过起点到终点的距离，所以本题的思路是从起点到终点之间二分，然后进行判断。如果起点和中间之间任意两个石头间的距离小于当前的距离，则需要移去一个石头，否则进行下一次判断。所有判断结束后如果要移走的石头数超过了可移走数$M$，则当前的距离不是最短跳跃距离的最大值，边界左移，否则边界右移</p></blockquote></blockquote><blockquote><blockquote><p>需要注意的地方是起点到终点之间有$N$块石头，如果算上起点和终点的话实际上有$N + 2$块石头，另外二分的判断过程有些复杂，所以我们按照标准的二分写法写一个判断函数<code>judge()</code>来进行判断</p></blockquote></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> mid, <span class="hljs-type">long</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len + <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">//在第一块石头和终点间进行判断</span><br>        <span class="hljs-keyword">if</span>(a[i] - a[now] &lt; mid)<br>            cnt++;<br>        <span class="hljs-keyword">else</span><br>            now = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt &lt;= m;    <span class="hljs-comment">/* </span><br><span class="hljs-comment">                            等价于:</span><br><span class="hljs-comment">                            if(cnt &lt;= m)</span><br><span class="hljs-comment">                                return true;</span><br><span class="hljs-comment">                            return false;</span><br><span class="hljs-comment">                        */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> distance, <span class="hljs-type">long</span> m)</span> </span>&#123;<br>    <span class="hljs-type">long</span> l = <span class="hljs-number">0</span>, r = distance + <span class="hljs-number">1</span>;    <span class="hljs-comment">//边界是起点和终点，避免特判将终点+1</span><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">long</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(a, len, mid, m))<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> l;   <span class="hljs-comment">//此时左边界就是所求的最短跳跃距离的最大值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">long</span> l, n, m, ans;<br>    cin &gt;&gt; l &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-type">long</span> a[n + <span class="hljs-number">2</span>];  <span class="hljs-comment">//实际上有n + 2个石头，我们把a[0]作为起点，a[n + 1]作为终点</span><br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    a[n + <span class="hljs-number">1</span>] = l;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br>    <br>    ans = <span class="hljs-built_in">binary_search</span>(a, n, l, m);<br>    <br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="P1182-数列分段-Section-II"><a href="#P1182-数列分段-Section-II" class="headerlink" title="P1182 数列分段 Section II"></a>P1182 数列分段 Section II</h3><h1 id="数列分段-Section-II"><a href="#数列分段-Section-II" class="headerlink" title="数列分段 Section II"></a>数列分段 Section II</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>对于给定的一个长度为N的正整数数列 $A_{1\sim N}$，现要将其分成 $M$（$M\leq N$）段，并要求每段连续，且每段和的最大值最小。</p><p>关于最大值最小：</p><p>例如一数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段。</p><p>将其如下分段：</p><p>$$[4\ 2][4\ 5][1]$$</p><p>第一段和为 $6$，第 $2$ 段和为 $9$，第 $3$ 段和为 $1$，和最大值为 $9$。</p><p>将其如下分段：</p><p>$$[4][2\ 4][5\ 1]$$</p><p>第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$，和最大值为 $6$。</p><p>并且无论如何分段，最大值不会小于 $6$。</p><p>所以可以得到要将数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行包含两个正整数 $N,M$。  </p><p>第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，含义如题目所述。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个正整数，即每段和最大值最小为多少。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>对于 $20%$ 的数据，$N\leq 10$。</p><p>对于 $40%$ 的数据，$N\leq 1000$。</p><p>对于 $100%$ 的数据，$1\leq N\leq 10^5$，$M\leq N$，$A_i &lt; 10^8$， 答案不超过 $10^9$。</p><blockquote><blockquote><p><del>这道题看了大半天题解才知道怎么做</del><br>我们的思路是直接二分每段和的最大值，当按照这个最大值划分的段数超过指定的段数时就证明当前的值并非最大值，要继续往右搜索，相反如果段数没有达到指定段数就说明当前值超过了最大值，要往左搜索<br>所以对于本题的左边界应该为将$n$个数分成$n$段时的每段和的最大值，即数列$A_n$的最大值，右边界为将$A_n$划分为一段时这段的长度，即$sumA_n$</p></blockquote></blockquote><blockquote><blockquote><p>另外本题所用的二分模板和上面几道题的二分模板不同，两个模板的思路是相同的，但是对于本题我们在求得$mid$后还需要根据是否满足$judge()$向终点的左边或右边搜索<del>其实这个模板做上面的题也可以，只是我不喜欢这样写</del></p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> m)</span> </span>&#123;<br>    <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里我是这样理解的：任何情况下都至少会将数列分成1层</span><br><span class="hljs-comment">        所以我们直接从一层开始计算。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span>(sum + a[i] &lt;= x) &#123; <span class="hljs-comment">//当累加的值还没有超过最大值时，不算做一层，继续累加</span><br>            sum += a[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cnt ++;     <span class="hljs-comment">//当累加值超过最大值时，已经达到了一层，层数+1</span><br>            sum = a[i]; <span class="hljs-comment">//从当前元素开始累加进行新一层的计算</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cnt &lt;= m;    <span class="hljs-comment">//当cnt不超过m时说明当前的值达到了最大值，移动右边界</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> maxn, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">long</span> sum, <span class="hljs-type">long</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> l = maxn, r = sum;<br>    <span class="hljs-keyword">while</span>(l &lt;= r) &#123;<br>        <span class="hljs-type">long</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(a, len, mid, m)) &#123;<br>            r = mid - <span class="hljs-number">1</span>;    <span class="hljs-comment">//向左搜索</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            l = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">//向右搜索</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l;   <span class="hljs-comment">//此时左端点就是最大值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">long</span> n, m, maxn = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">long</span> a[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        maxn = <span class="hljs-built_in">max</span>(maxn, a[i]); <span class="hljs-comment">//左端点</span><br>        cnt += a[i];    <span class="hljs-comment">//右端点</span><br>    &#125;<br>    <br>    <span class="hljs-type">long</span> ans = <span class="hljs-built_in">binary_search</span>(a, n, maxn, cnt, m);<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="P3743-kotori的设备"><a href="#P3743-kotori的设备" class="headerlink" title="P3743 kotori的设备"></a>P3743 kotori的设备</h3><h1 id="kotori的设备"><a href="#kotori的设备" class="headerlink" title="kotori的设备"></a>kotori的设备</h1><h2 id="题目背景-3"><a href="#题目背景-3" class="headerlink" title="题目背景"></a>题目背景</h2><p>kotori 有 $n$ 个可同时使用的设备。</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>第 $i$ 个设备每秒消耗 $a_i$ 个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在 $k$ 秒内消耗的能量均为 $k\times a_i$ 单位。在开始的时候第 $i$ 个设备里存储着 $b_i$ 个单位能量。</p><p>同时 kotori 又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 $p$ 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。</p><p>kotori 想把这些设备一起使用，直到其中有设备能量降为  $0$。所以 kotori 想知道，在充电器的作用下，她最多能将这些设备一起使用多久。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行给出两个整数 $n,p$。</p><p>接下来 $n$ 行，每行表示一个设备，给出两个整数，分别是这个设备的 $a_i$ 和 $b_i$。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果 kotori 可以无限使用这些设备，输出 $-1$。</p><p>否则输出 kotori 在其中一个设备能量降为 $0$ 之前最多能使用多久。</p><p>设你的答案为 $a$，标准答案为 $b$，只有当 $a,b$ 满足<br>$\dfrac{|a-b|}{\max(1,b)} \leq 10^{-4}$ 的时候，你能得到本测试点的满分。</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">0000000000</span><br></code></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">100</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">5000000000</span><br></code></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>对于 $100%$ 的数据，$1\leq n\leq 100000$，$1\leq p\leq 100000$，$1\leq a_i,b_i\leq100000$。</p><blockquote><blockquote><p>对于本题，我们可以理解为当k秒内消耗的电量$k\times a_i$超过了其本身的电量$b_i$，那么它在若干秒后就会用完电量，而我们要在使用所有设备的同时尽量让它们的使用时间长，也就是说要让第一个设备电量用完的情况尽可能晚的出现。我们可以让目前电量最少的设备接上充电宝，此时它的耗电就成了$k\times (a_i - p)$，当其它设备成为电量最少的设备时，我们将充电宝重新接到这个设备上<br>由于切换设备的时间是忽略不计的，我们可以当作以上行为是可以在瞬间内完成的，所以我们可以直接将它们累加到一起直接进行计算。那么我们就有了$n$个设备每秒消耗的电量$\sum_{i&#x3D;1}^{n} a_i$    </p></blockquote></blockquote><blockquote><blockquote><p>现在我们需要考虑如何通过程序来解决问题<br>我们可以二分查找这些设备的最大使用时间$x$，那么在x秒内我们通过充电宝一共可以供电$x \times p$，我们记作$q$。现在对每一个设备进行判断，如果第$i$个设备$x$秒内消耗的电量$a_i \times x$没有超过这个设备本身的电量$b_i$，就说明这个设备不需要充电，如果超过了这个电量我们就需要冲$a_i \times x - b_i$的电，最后所有设备一共要冲$\sum_{i&#x3D;1}^{n} a_i \times x - b_i$的电，我们记作$sum$，如果$sum &gt; q$说明当前的时间超过了最大使用时间，应该将右边界左移缩小范围；反之如果$sum \leq q$，说明当前时间没有超过最大使用时间，应该移动左边界继续查找。<br>另外当可以无限使用设备，即永远不会有设备没电时输出$-1$。我们可以进行特判，当可以无限使用设备时就说明所有设备每秒消耗的总电量永远不会超过充电宝每秒充入的电量，是否还记得上面的$\sum_{i&#x3D;1}^{n} a_i$，我们将其记作$t$，那么当$t \leq p$时，输出$-1$</p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> a[], <span class="hljs-type">double</span> b[], <span class="hljs-type">double</span> p,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">long</span> len)</span> </span>&#123;<br>        <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>, q = x * p;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span>(a[i] * x &lt;= b[i])<br>                <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">//不需要充电，判断下一个</span><br>            <span class="hljs-keyword">else</span><br>                sum += (a[i] * x - b[i]);   <span class="hljs-comment">//对需要充入的电量累加</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sum &lt;= q;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            如果充入的电量没有超过x秒内可以提供的电量</span><br><span class="hljs-comment">            则当前结果可行</span><br><span class="hljs-comment">        */</span><br>    &#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">double</span> a[], <span class="hljs-type">double</span> b[], <span class="hljs-type">long</span> len,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span> p)</span> </span>&#123;<br>        <span class="hljs-type">double</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e10</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            直接将左端点定义为0，右端点定义为足够大的值</span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">             二分的时间复杂度是O(logn)，当执行一千次时精度绝对可以满足题目要求，可以省去对边界的判断</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;     <br>            <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid, a, b, p, len))<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> l;   <span class="hljs-comment">//此时左端点就为答案</span><br>    &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">long</span> n;<br>    <span class="hljs-type">double</span> p, t = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; p;<br>    <span class="hljs-type">double</span> a[n], b[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i] &gt;&gt; b[i];<br>        t += a[i];  <span class="hljs-comment">//对每秒消耗的电量进行累加</span><br>    &#125;<br><br>    ans = <span class="hljs-built_in">binary_search</span>(a, b, n, p);<br>    <span class="hljs-keyword">if</span>(t &lt;= p)   <span class="hljs-comment">//特判</span><br>        ans = <span class="hljs-number">-1</span>;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="P3853-TJOI2007-路标设置"><a href="#P3853-TJOI2007-路标设置" class="headerlink" title="P3853 [TJOI2007]路标设置"></a>P3853 [TJOI2007]路标设置</h3><h1 id="TJOI2007-路标设置"><a href="#TJOI2007-路标设置" class="headerlink" title="[TJOI2007]路标设置"></a>[TJOI2007]路标设置</h1><h2 id="题目背景-4"><a href="#题目背景-4" class="headerlink" title="题目背景"></a>题目背景</h2><p>B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。</p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行包括三个数 $L,N,K$，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。</p><p>第 $2$ 行包括递增排列的 $N$ 个整数，分别表示原有的 $N$ 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 $[0,L]$ 内。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $1$ 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">101 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">101</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">51<br></code></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。</p><p>$50%$ 的数据中，$2 \leq N \leq 100$，$0 \leq K \leq 100$。</p><p>$100%$ 的数据中，$2 \leq N \leq 100000$, $0 \leq K \leq100000$。</p><p>$100%$ 的数据中，$0 &lt; L \leq 10000000$。</p><blockquote><blockquote><p>这道题是这个题单中唯一一道普及+&#x2F;提高的题，不过要理解起来其实也很容易。实际上这道题和上面的<code>[NOIP2015 提高组] 跳石头</code>有点像，只是跳石头是在最短跳跃距离的最大值，本题是在求最小的“空旷指数”值</p></blockquote></blockquote><blockquote><blockquote><p>本题也是用通过二分查找能够满足要求的“空旷指数”<del>（也就是二分答案，但是之前好像没有提到过）</del>，根据题目我们知道路标的位值一定在区间$[0, L]$内，所以我们可以将左右边界分别定义为$0$和输入的$L$<br>那么本题的思路就是判断每两个相邻路标之间的距离，如果距离大于我们给定的“空旷指数”$mid$，我们就在与第一个路标距离$mid$处添加一个路标，然后再次进行判断，知道两个路标之间距离小于$mid$，依次枚举后，我们就得到了在当前“空旷指数”下要添加的路标数$cnt$，当添加的路标数量超过了规定的最多可增设路标数量$k$，也就是$cnt &gt; k$时，说明目前的答案大于最小空旷指数，我们应该移动左端点，相反当$cnt \geq k$时，我们移动右端点，判断结束后右端点就是我们的答案<br>本题最值的注意的地方时我们进行二分时如果$cnt &gt; k$时，移动的是<strong>左端点</strong>，而最终答案是<strong>右端点</strong>，这与我们之前的题目相反。另外本题我们需要输入$n$个数，但是包含这些数的数组长度应该是$n + 2$，因为我我们需要用第一个元素存储起点，最后一个元素存储终点</p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len + <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> dinstance = a[i] - a[i - <span class="hljs-number">1</span>];     <span class="hljs-comment">//用来存放两个路标间的距离也就是“空旷指数”</span><br>        <span class="hljs-keyword">if</span>(dinstance &gt; mid) &#123; <span class="hljs-comment">//如果两个路标间的距离大于mid，增设路标</span><br>            cnt++;<br>            <span class="hljs-type">int</span> t = dinstance - mid;<br>            <span class="hljs-keyword">while</span>(t &gt; mid) &#123;    <span class="hljs-comment">//增设路标后继续判断，直到路标间的距离不超过mid</span><br>                cnt++;<br>                t -= mid;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cnt &lt;= k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> finish, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = finish;   <span class="hljs-comment">//参数finish即终点（准确的说是终点到起点的距离）</span><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;     <span class="hljs-comment">//本题还是用这个二分模板，我个人很喜欢这个模板，能省去不少判断边界的麻烦</span><br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid, a, len, k))<br>            r = mid;            <span class="hljs-comment">//注意此时要移动右端点</span><br>        <span class="hljs-keyword">else</span><br>            l = mid;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> r;       <span class="hljs-comment">//答案也是右端点</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l, n, k;<br>    cin &gt;&gt; l &gt;&gt; n &gt;&gt; k;<br><br>    <span class="hljs-type">int</span> a[n + <span class="hljs-number">2</span>];<br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;       <span class="hljs-comment">//存放起点</span><br>    a[n + <span class="hljs-number">1</span>] = l;   <span class="hljs-comment">//存放终点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">binary_search</span>(a, n, l, k);<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这个题单还有两道题，但是一道据说用二分只是一种特殊解法，实际上应该是双指针的模板题<del>而且我还不会做</del>，另一道题看不明白，所以这里就不写了<del>看以后有没有心情去做</del>，所以这个二分题单在这里就告一段落</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2023/04/03/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/04/03/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//给出一个有序数组，求该数组中第一个&gt;5的数的位置和最后一个&lt;=5的数的位置</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//第一个&gt;5的数的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search1</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = len;<br><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &lt;= x)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-comment">//最后一个&lt;=5的数的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search2</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = len;<br><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &gt; x)<br>            r = mid;<br>        <span class="hljs-keyword">else</span><br>            l = mid;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(a) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><br>    <span class="hljs-comment">//第一个&gt;5的数的位置</span><br>    cout &lt;&lt; <span class="hljs-built_in">binary_search1</span>(a, len, <span class="hljs-number">5</span>) &lt;&lt; endl;<br>    <span class="hljs-comment">//最后一个&lt;=5的数的位置</span><br>    cout &lt;&lt; <span class="hljs-built_in">binary_search2</span>(a, len, <span class="hljs-number">5</span>) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//输入一个浮点数n(-10000 &lt;= n &lt;= 10000)，求n的三次方根，小数点向后保留六位</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">double</span> n;<br>    cin &gt;&gt; n;    <br><br>    <span class="hljs-type">double</span> l = <span class="hljs-number">-100</span>, r = <span class="hljs-number">100</span>;   <span class="hljs-comment">//-10000 &lt;= n &lt;= 10000，所以n的三次方根c -100 &lt;= c &lt;= 100</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123; <br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid * mid * mid &lt;= n)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125; <br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        循环执行100次后能够将答案精度控制在小数点后30位(但是double的精度大概是15-17位)，此时l和r将会非常接近，将答案四舍五入到6位后 l == r</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6f\n&quot;</span>, l);<br>    <span class="hljs-comment">//printf(&quot;%.6f\n&quot;, r);</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023.3.11</title>
    <link href="/2023/03/10/2023-3-11/"/>
    <url>/2023/03/10/2023-3-11/</url>
    
    <content type="html"><![CDATA[<p>最近都在看其他的，都快忘了《沉默的大多数》还没看完。抽空把这本杂文集的最后一篇《沉默的大多数》看完了，终于算是看完了全本，这里就写一写类似于读后感的东西吧。</p><p>我记得以前就有说过这些杂文都是在作者生命的最后几年时间写下的。作者用犀利的语言表达着他对社会的思考，批判者社会上的丑恶。现在想来，批判的成分其实应该不多，应该说作者的本意不是批判。他说“沉默是一种生活方式“，他也以这样的方式生活着，只是当写作时才以文字为载体把话都说了出来。他只是在讲述自己的所看和所想而已。</p><p>在看王小波的小说时我们能深刻的感受到他的黑色幽默，有时在看一篇小说的时候我总是花很长的时间思考这个荒诞的故事背后有什么深刻的含义，但总是百思不得其解。后来我又觉得也许它没有什么对社会的思考或者含蓄的表达，王小波也不是鲁迅拿卓在黑暗中战斗的大文豪、思想家——所以它也许只是单纯的在讲一个故事而已。我又想让读者费劲心思去思考本没有什么内涵的小说的内涵，最后无论是得出它没有内涵的结论（当然你也可以说它在反映现实）或者编出了一个什么内涵，这一整件事都算是黑色幽默——虽然这不是作者的本意。</p><p>当看到王小波的杂文时，我对作者的认识便与看小说时有了很大的差别，当然那种刻在骨子里的黑色幽默依然存在，不过只算做点缀，作者用自己的视角而不是“王二“或者小说中的”我“表达自己的思考。我曾经惊叹于他竟然在那个时期直白的描述文革，描述社会问题，批判儒学，甚至关注同性恋这样的少数群体（这样的事情如今看来不足为奇，但我们需要了解一下当时的社会环境）。现在看来他应该没有做激烈的思想斗争，也没有激发大无畏的勇气和毅力。他是一个学者，做了一项社会学研究，于是把自己的思考写出来；或者他经历了一些动荡，看到了一些丑恶，他觉得不好，于是用文字表达了一下什么不好、为什么不好。没有大清的文字狱，写些弯弯绕绕的没什么意义，所以他也没有必要那样写。作为一个生活在沉默中的人，做出这样的事情反而是最让人不足为奇的，正如他所说：“对信得过的人什么都说，对信不过的人什么都不说。”他只是什么都说了，仅此而已。</p><p>他说他后来也做一些发言，也写一些稿子，他说这如同失去了童贞一样。他不再沉默，但他代表着的确是“沉默的大多数“。<br>有许多青年曾经追随他——在他逝世之后。人们说他是叛逆的代表，我觉得他所表现出来的叛逆源于他曾经的沉默。我应当也是追随他的青年中的一员。</p><p>引用一下《沉默的大多数》的结尾作为我的结尾：<br>“几年前，我刚刚走出沉默，写了一本书，送给长者看。他不喜欢这本书，认为书不能这样来写。找他来看，写书就应该能教育人民，提升人的灵魂。这真是金玉良言。但在这世界上的一切人之中，我最希望予以提升的一个，就是我自己。这话很卑鄙，很自私，也很诚实。“</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记2023-2-18</title>
    <link href="/2023/02/18/%E6%97%A5%E8%AE%B02023-2-18/"/>
    <url>/2023/02/18/%E6%97%A5%E8%AE%B02023-2-18/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">竟然在太原的一家书店里发现了王小波的杂文集《沉默的大多数》，其实我很早之前就可以在网上买，但是在实体书店真实的触碰到放在书架上还没售出的书真的让我欣喜若狂，于是我毫不犹豫的买了下来。</code></pre><p>我每去一个地方都会选择去看一看当地的书店或图书馆，但这次给我的惊喜是最大的。很早之前我对王小波的了解仅限于他是一个程序员、学数学出身的作家，只知道他有一句话叫做“绝望是无限的美好”，知道这<br>句话有相当程度的原因是因为当时这句话因为被荼毒在网上盛行。今天我读了扉页上的一段话才找到了他身上最让我崇敬的精神——我觉得我还不足以与他产生共鸣，我只是对他的观念崇敬。他写到：一个只会明辨<br>是非的人若是凭脑海中的浩然正气做出一个判断，然后加上一句：难道这不是不言而喻的吗？任何受过一点科学训练的人都知道，这世界上简直找不到什么不言而喻的事，所以这就叫做愚蠢。我要反对愚蠢。</p><p>2023.2.18 于太原</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记2022.11.9</title>
    <link href="/2022/11/09/%E6%97%A5%E8%AE%B02022-11-9/"/>
    <url>/2022/11/09/%E6%97%A5%E8%AE%B02022-11-9/</url>
    
    <content type="html"><![CDATA[<p>2022.11.9 早<br>    昨天晚上和UE4磕了一晚上，越到了后面就越要求能够理解事件的执行机制（优先级什么的），乱用流程结构总是会导致有很多bug，但是这对于初学者，尤其是没有编程基础，不懂得程序设计思想的初学者而言是十分困难的。如果UE4的蓝图有完善的调试功能则可以在很大程度上解决问题。当下的问题就是对于初学者而言他， 无法了解一些深层机制，也无法通过经验解决问题，而一些深入剖析UE底层原理的内容只有经验丰富的老手才能看懂。这也是将一些抽象的东西变得具象化要面对的必然问题，尤其是对于UE这种体量如此之大的游戏引擎而言，所以关于UE的学习必然要伴随着对一些概念和理论的学习和理解。</p><pre><code class="hljs">另外我想起刚去职校的时候有个朋友和我说过一定要参加比赛，就拿如今的省赛来说参加比赛确实是一个好的学习方式，就比如现在学习的UE和我同学学习的建模，确实都是非常实用的技能，即使只有两三个月学习的时间也足</code></pre><p>以学到很多。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2022/10/12/%E6%A0%88/"/>
    <url>/2022/10/12/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<ul><li><p>栈的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        ElemType data[<span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> top;<br>&#125;SqStack;<br></code></pre></td></tr></table></figure></li><li><p>栈的基本操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//栈的初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">StackInit</span><span class="hljs-params">(SqStack *p)</span> &#123;<br>        *p-&gt;data = <span class="hljs-literal">NULL</span>;<br>        p-&gt;top = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//进栈</span><br>Status <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack *S, ElemType e)</span> &#123;<br>        <span class="hljs-keyword">if</span>(S-&gt;top == MAXSIZE - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> ERROR;<br>        S-&gt;top++;<br>        S-&gt;data[S-&gt;top] = e;<br><br>        <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//出栈</span><br>Status <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack *S, ElemType *e)</span> &#123;<br>        <span class="hljs-keyword">if</span>(S-&gt;top == <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> ERROR;<br>        *e = S-&gt;data[S-&gt;top];<br>        S-&gt;top--;<br>        <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表的整表创建和整表删除</title>
    <link href="/2022/10/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%92%8C%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4/"/>
    <url>/2022/10/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%92%8C%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="单链表的整表创建和删除"><a href="#单链表的整表创建和删除" class="headerlink" title="单链表的整表创建和删除"></a>单链表的整表创建和删除</h1><ul><li><p>单链表的整表创建</p><ul><li><p>头插法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-type">void</span> <span class="hljs-title function_">CreateListHead</span><span class="hljs-params">(LinkList *L, <span class="hljs-type">int</span> n)</span> &#123;<br>            linKlist p;<br>            <span class="hljs-type">int</span> i;<br>    <br>            srand(time(<span class="hljs-number">0</span>));<br>    <br>            *L = (LinkList)Malloc(<span class="hljs-keyword">sizeof</span>(Node));<br>            (*L) -&gt; next = <span class="hljs-literal">NULL</span>;<br>    <br>            <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                    p = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>                    p-&gt;data = rand() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>                    p-&gt;next = (*L)-&gt;next;<br>                    (*L)-&gt;next = p;<br>            &#125;<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li><li><p>尾插法</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">CreateListTail</span><span class="hljs-params">(LinkList *L, <span class="hljs-type">int</span> n)</span> &#123;<br>        linklist p, r;<br>        <span class="hljs-type">int</span> i;<br><br>        strand(time(<span class="hljs-number">0</span>));<br>        *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>        r= *L;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                p = (Node *)Malloc(<span class="hljs-keyword">sizeof</span>(Node));<br>                p-&gt;data = rand() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>                r-&gt;next = p;<br>                r = p;<br>        &#125;<br><br>      r-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>单链表的整表删除</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ClearList</span><span class="hljs-params">(LinList *L)</span> &#123;<br>        LinKList p, q;<br><br>        p = (*L)-&gt;next;<br><br>        <span class="hljs-keyword">while</span>(p) &#123;<br>                q = p-&gt;next;<br>                <span class="hljs-built_in">free</span>(p);<br>                p = q;<br>        &#125;<br><br>        (*L)-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表插入和删除</title>
    <link href="/2022/10/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/"/>
    <url>/2022/10/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="单链表的插入和删除"><a href="#单链表的插入和删除" class="headerlink" title="单链表的插入和删除"></a>单链表的插入和删除</h1><ul><li><p>引用和约定俗成的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">Next</span>;</span><br>&#125; Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></td></tr></table></figure><ul><li><p>插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">LinkInsert</span><span class="hljs-params">(LinkList *L, <span class="hljs-type">int</span> i, ElemType e)</span> &#123;<br>    <span class="hljs-type">int</span> j;<br>    LinkInsert p, s;<br>    <br>    j = <span class="hljs-number">1</span>;<br>    p = L-&gt;next;<br>    <br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i) &#123;<br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j &gt; i) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <br>    s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    s-&gt;data = e;<br>    <br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(LinkList *L, <span class="hljs-type">int</span> i, ElemType *e)</span> &#123;<br>    <span class="hljs-type">int</span> j;<br>    LinkList p, q;<br>   j = <span class="hljs-number">1</span>;<br>    p = *L;<br>    <br>    <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i) &#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next) || j &gt; i) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <br>    q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    <br>    *e = q-&gt;data;<br>    <span class="hljs-built_in">free</span>(q);<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表顺序存储</title>
    <link href="/2022/10/06/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/"/>
    <url>/2022/10/06/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h1><ul><li><p>约定俗成的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 20 <span class="hljs-comment">//此处定义为20</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br></code></pre></td></tr></table></figure></li><li><p>结构定义</p></li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ElemType data[MAXSIZE];<br>    <span class="hljs-type">int</span> length;<br>&#125; SqList;<br></code></pre></td></tr></table></figure><ul><li>读取操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType *e)</span> &#123;<br>    <span class="hljs-keyword">if</span>(L.length == <span class="hljs-number">0</span> || i &lt; <span class="hljs-number">1</span> || i &gt; L.length) &#123;<br>            <span class="hljs-keyword">return</span> ERROR;<br>        &#125;<br>    *e = L.data[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>并集操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unionL</span><span class="hljs-params">(List *La, List lb)</span> &#123;<br>    <span class="hljs-type">int</span> La_len, Lb_len, i;<br>    <br>    ElemType e;<br>    La_len = ListLength(*La);<br>    Lb_len = ListLength(Lb);<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= b; i++) &#123;<br>        GetElem(Lb, i, &amp;e);<br>        <span class="hljs-keyword">if</span>(!LocateElem(*La, e)) &#123;<br>            ListInsert(La, ++La_len. e);<br>        &#125;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>插入操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> i, ElemType e)</span> &#123;<br>        <span class="hljs-type">int</span> k;<br><br>        <span class="hljs-keyword">if</span>(L-&gt;length == MAXSIZE) &#123;<br>                <span class="hljs-keyword">return</span> ERROR;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;Length + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> ERROR;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &lt;= L-&gt;length) &#123;<br>                <span class="hljs-keyword">for</span>(k = L-&gt;length - <span class="hljs-number">1</span>; k &gt;= i - <span class="hljs-number">1</span>; k--) &#123;<br>                                        L-&gt;data[k + <span class="hljs-number">1</span>] = L-&gt;data[k];<br>                                &#125;<br>        &#125;<br><br>        L-&gt;data[i - <span class="hljs-number">1</span>] = e;<br>        L-&gt;length++;<br><br>        <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>删除操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> i, ElemType *e)</span> &#123;<br>        <span class="hljs-type">int</span> k;<br><br>        <span class="hljs-keyword">if</span>(L-&gt;length == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> ERROR;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;length)<br>                <span class="hljs-keyword">return</span> ERROR;<br><br>        *e = L-&gt;datap[i - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">if</span>(i &lt; L-&gt;length) &#123;<br>                <span class="hljs-keyword">for</span>(k = i; k &lt; L-&gt;length; k++) &#123;<br>                        L-&gt;data[k - <span class="hljs-number">1</span>] = L-&gt;data[k];<br>                &#125;<br>        &#125;<br><br>        L-&gt;length--;<br>        <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表的插入和删除操作</title>
    <link href="/2022/10/05/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/10/05/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表的插入和删除操作"><a href="#线性表的插入和删除操作" class="headerlink" title="线性表的插入和删除操作"></a>线性表的插入和删除操作</h1><ul><li><p>插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> i, ElemType e)</span> &#123;<br>    <span class="hljs-type">int</span> k;<br>    <br>    <span class="hljs-keyword">if</span>(L-&gt;length == MAXSIZE)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;length + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span>(i &lt;= L-&gt;length) &#123;<br>        <span class="hljs-keyword">for</span>(k = L-&gt;length - <span class="hljs-number">1</span>; k &gt;= i - <span class="hljs-number">1</span>; k--) <br>            L-&gt;data[k + <span class="hljs-number">1</span>] = L-&gt;data[k];<br>    &#125;<br>    <br>L-&gt;data[i - <span class="hljs-number">1</span>] = e;<br>    L-&gt;length++;<br>    <br>    <span class="hljs-keyword">return</span> OK<br>&#125;<br></code></pre></td></tr></table></figure><p>插入的时间复杂度为</p></li><li><p>删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> i, ElemType *e)</span> &#123;<br>    <span class="hljs-type">int</span> k;<br>    <br>    <span class="hljs-keyword">if</span>(L-&gt;length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;length) <br>        <span class="hljs-keyword">return</span> ERROR;<br>    *e = L-&gt;data[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">if</span>(i &lt; L-&gt;length) &#123;<br>        <span class="hljs-keyword">for</span>(k = i; k &lt; L-&gt;length; k++)<br>            L-&gt;data[k - <span class="hljs-number">1</span>] = L-&gt;data[k];<br>    &#125;<br>    <br>    L-&gt;length --;<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>时间复杂度：</p><h6 id="最好情况："><a href="#最好情况：" class="headerlink" title="最好情况："></a>最好情况：</h6><p>如果要插入或删除的元素在最后一个位置，时间复杂度为O(1)</p><h6 id="最坏情况："><a href="#最坏情况：" class="headerlink" title="最坏情况："></a>最坏情况：</h6><p>如果要插入或删除的元素在第一个位置，则要进行n次操作，时间复杂度为O(n)</p><h6 id="平均情况："><a href="#平均情况：" class="headerlink" title="平均情况："></a>平均情况：</h6><p>O((n - 1) &#x2F; 2)</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>text</title>
    <link href="/2022/10/05/text/"/>
    <url>/2022/10/05/text/</url>
    
    <content type="html"><![CDATA[<ul><li>this is a test text</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/04/hello-world/"/>
    <url>/2022/10/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
